/********************************************************************************
 * File: mod_funcs.hpp
 * Author: ppkantorski
 * Description:
 *   This header file contains function declarations and utility functions for IPS
 *   binary generations. These functions are used in the Ultrahand Overlay project
 *   to convert `.pchtxt` mods into `.ips` binaries.
 *
 *   For the latest updates and contributions, visit the project's GitHub repository.
 *   (GitHub Repository: https://github.com/ppkantorski/Ultrahand-Overlay)
 *
 *   Note: Please be aware that this notice cannot be altered or removed. It is a part
 *   of the project's documentation and must remain intact.
 * 
 *  Licensed under both GPLv2 and CC-BY-4.0
 *  Copyright (c) 2024 ppkantorski
 ********************************************************************************/

#include <mod_funcs.hpp>

namespace ult {
    const char* IPS32_HEAD_MAGIC = "IPS32";
    const char* IPS32_FOOT_MAGIC = "EEOF";
    //const std::string CHEAT_HEADER = "// auto generated by pchtxt2cheat\n\n";
    const std::string CHEAT_TYPE = "04000000";
    const std::string CHEAT_EXT = ".txt";
    const std::string CHEAT_ENCODING = "ascii";
    
    
    
    /**
     * @brief Checks if a cheat already exists in the cheat file.
     * @param cheatFilePath The path to the cheat file.
     * @param newCheat The new cheat to check.
     * @return True if the cheat exists, otherwise false.
     */
    bool cheatExists(const std::string& cheatFilePath, const std::string& newCheat) {
    #if NO_FSTREAM_DIRECTIVE
        FILE* cheatFile = fopen(cheatFilePath.c_str(), "r");  // Open the cheat file in read mode
        if (!cheatFile) {
            return false;  // Return false if the file cannot be opened
        }
    
        char buffer[1024];  // Buffer to store each line
        while (fgets(buffer, sizeof(buffer), cheatFile)) {
            // Remove newline character, if present
            size_t len = strlen(buffer);
            if (len > 0 && buffer[len - 1] == '\n') {
                buffer[len - 1] = '\0';
            }
            if (newCheat == buffer) {
                fclose(cheatFile);  // Close the file before returning
                return true;  // Cheat exists
            }
        }
    
        fclose(cheatFile);  // Close the file after processing
        return false;  // Cheat does not exist
    #else
        std::ifstream cheatFile(cheatFilePath);
        if (!cheatFile) {
            return false;  // Return false if the file cannot be opened
        }
    
        std::string line;
        while (std::getline(cheatFile, line)) {
            if (line == newCheat) {
                return true;  // Cheat exists
            }
        }
        return false;  // Cheat does not exist
    #endif
    }
    
    /**
     * @brief Appends a new cheat to the cheat file.
     * @param cheatFilePath The path to the cheat file.
     * @param newCheat The new cheat to append.
     */
    void appendCheatToFile(const std::string& cheatFilePath, const std::string& newCheat) {
    #if NO_FSTREAM_DIRECTIVE
        FILE* cheatFile = fopen(cheatFilePath.c_str(), "a");  // Open the cheat file in append mode
        if (!cheatFile) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Failed to open cheat file for appending: " + cheatFilePath);
            #endif
            return;  // Handle the error accordingly
        }
    
        fprintf(cheatFile, "%s\n", newCheat.c_str());  // Write the new cheat followed by a newline
        fclose(cheatFile);  // Close the file
    #else
        std::ofstream cheatFile(cheatFilePath, std::ios::app);
        if (!cheatFile) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Failed to open cheat file for appending: " + cheatFilePath);
            #endif
            return;  // Handle the error accordingly
        }
    
        cheatFile << newCheat << std::endl;  // Write the new cheat
    #endif
    }
    
    
    /**
     * @brief Extracts the cheat name from the given file path.
     * @param filePath The full file path.
     * @return The extracted cheat name.
     */
    std::string extractCheatName(const std::string &filePath) {
        size_t lastSlash = filePath.find_last_of("/\\");
        if (lastSlash == std::string::npos) {
            return "";
        }
        size_t secondLastSlash = filePath.find_last_of("/\\", lastSlash - 1);
        if (secondLastSlash == std::string::npos) {
            return "";
        }
        std::string lastDir = filePath.substr(secondLastSlash + 1, lastSlash - secondLastSlash - 1);
        std::string fileName = filePath.substr(lastSlash + 1);
        size_t dotPos = fileName.find_last_of('.');
        if (dotPos != std::string::npos) {
            fileName = fileName.substr(0, dotPos);
        }
    
        // If lastDir contains " - ", extract the part after " - "
        size_t dashPos = lastDir.find(" - ");
        std::string cheatName = lastDir;
        if (dashPos != std::string::npos) {
            cheatName = lastDir.substr(dashPos + 3);
        }
    
        return cheatName + " " + fileName;
    }
    
    // Helper function to determine if a string is a valid title ID
    bool isValidTitleID(const std::string &str) {
        if (str.length() != 16) return false;
        for (char c : str) {
            if (!std::isxdigit(c)) return false; // Check if each character is a hexadecimal digit
        }
        return true;
    }
    
    // Function to find the title ID in the text, avoiding the @nsobid- line
    std::string findTitleID(const std::string &text) {
        size_t nsobidPos = text.find("@nsobid-");
        size_t startPos = (nsobidPos != std::string::npos) ? nsobidPos + 40 + 8 : 0; // Skip past @nsobid- and its value
    
        for (size_t i = startPos; i <= text.length() - 16; ++i) {
            std::string potentialID = text.substr(i, 16);
            if (isValidTitleID(potentialID)) {
                return potentialID;
            }
        }
        return "";
    }
    
    
    /**
     * @brief Converts a .pchtxt file to a cheat file.
     * @param pchtxtPath The file path to the .pchtxt file.
     * @param cheatName The name of the cheat.
     * @param outCheatPath The file path for the output cheat file.
     * @return True if the conversion was successful, false otherwise.
     */
    bool pchtxt2cheat(const std::string &pchtxtPath, std::string cheatName, std::string outCheatPath) {
        #if USING_LOGGING_DIRECTIVE
        logMessage("Starting pchtxt2cheat with pchtxtPath: " + pchtxtPath);
        #endif
    
    #ifdef NO_FSTREAM_DIRECTIVE
        FILE* pchtxtFile = fopen(pchtxtPath.c_str(), "r");
        if (!pchtxtFile) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Error: Unable to open file " + pchtxtPath);
            #endif
            return false;
        }
    
        // Read the entire file into a string
        std::string pchtxt;
        char buffer[4096];
        while (fgets(buffer, sizeof(buffer), pchtxtFile)) {
            pchtxt += buffer;
        }
        fclose(pchtxtFile);
    #else
        std::ifstream pchtxtFile(pchtxtPath);
        if (!pchtxtFile) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Error: Unable to open file " + pchtxtPath);
            #endif
            return false;
        }
    
        std::string pchtxt((std::istreambuf_iterator<char>(pchtxtFile)), std::istreambuf_iterator<char>());
    #endif
    
        size_t nsobidPos = pchtxt.find("@nsobid-");
        if (nsobidPos == std::string::npos) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Error: Could not find bid in pchtxt file, the file is likely invalid.");
            #endif
            return false;
        }
    
        std::string bid = pchtxt.substr(nsobidPos + 8, 40);
        std::string bidShort = bid.substr(0, 16);
    
        std::string tid = findTitleID(pchtxt);
        if (tid.empty()) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Error: Could not find TID in pchtxt file, the file is likely invalid.");
            #endif
            return false;
        }
    
        std::string cheatFilePath;
    
        if (outCheatPath.empty()) {
            std::string folderPath = "sdmc:/atmosphere/contents/" + tid + "/cheats/";
            createDirectory(folderPath);
            cheatFilePath = folderPath + bidShort + CHEAT_EXT;
        } else {
            cheatFilePath = outCheatPath;
        }
    
    #ifdef NO_FSTREAM_DIRECTIVE
        FILE* existingCheatFile = fopen(cheatFilePath.c_str(), "r");
        bool cheatNameExists = false;
        if (existingCheatFile) {
            char line[256];
            while (fgets(line, sizeof(line), existingCheatFile)) {
                if (std::string(line) == "[" + cheatName + "]\n") {
                    cheatNameExists = true;
                    break;
                }
            }
            fclose(existingCheatFile);
        }
    #else
        std::ifstream existingCheatFile(cheatFilePath);
        bool cheatNameExists = false;
        if (existingCheatFile) {
            std::string line;
            while (std::getline(existingCheatFile, line)) {
                if (line == "[" + cheatName + "]") {
                    cheatNameExists = true;
                    break;
                }
            }
        }
        existingCheatFile.close();
    #endif
    
        // Open output cheat file
    #ifdef NO_FSTREAM_DIRECTIVE
        FILE* outCheatFile = fopen(cheatFilePath.c_str(), "a");
        if (!outCheatFile) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Error: Unable to create cheat file " + cheatFilePath);
            #endif
            return false;
        }
    #else
        std::ofstream outCheatFile(cheatFilePath, std::ios::app);
        if (!outCheatFile) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Error: Unable to create cheat file " + cheatFilePath);
            #endif
            return false;
        }
    #endif
    
        if (!cheatNameExists) {
    #ifdef NO_FSTREAM_DIRECTIVE
            fprintf(outCheatFile, "[%s]\n", cheatName.c_str());
    #else
            outCheatFile << "[" << cheatName << "]\n";
    #endif
        }
    
        int offset = 0;
        std::istringstream iss(pchtxt);
        std::string line;
        while (std::getline(iss, line)) {
            trim(line);
            if (line.empty() || line[0] == '#') {
                continue;
            }
    
            if (line.find("@flag offset_shift ") == 0) {
                std::string offsetStr = line.substr(19);
                offset = (offsetStr.find("0x") == 0 ? std::strtol(offsetStr.c_str(), nullptr, 16) : std::strtol(offsetStr.c_str(), nullptr, 10)) - 0x100;
                continue;
            }
    
            if (line.find("@enabled") == 0) {
                continue;
            }
    
            if (line.find("@stop") == 0) {
                break;
            }
    
            size_t spacePos = line.find(' ');
            if (spacePos == std::string::npos) {
                continue;
            }
    
            std::string addrStr = line.substr(0, spacePos);
            std::string valStr = line.substr(spacePos + 1);
    
            if (addrStr.find_first_not_of("0123456789abcdefABCDEF") != std::string::npos || valStr.find_first_not_of("0123456789abcdefABCDEF") != std::string::npos) {
                continue;
            }
    
            int codeOffset = std::strtol(valStr.c_str(), nullptr, 16) + offset;
            char buffer[9];
            snprintf(buffer, sizeof(buffer), "%08X", codeOffset);
            std::string cheatLine = CHEAT_TYPE + " " + addrStr + " " + hexToReversedHex(buffer);
            
    #ifdef NO_FSTREAM_DIRECTIVE
            // Check if cheat already exists
            FILE* checkFile = fopen(cheatFilePath.c_str(), "r");
            bool exists = false;
            if (checkFile) {
                char checkLine[256];
                while (fgets(checkLine, sizeof(checkLine), checkFile)) {
                    if (std::string(checkLine) == cheatLine + "\n") {
                        exists = true;
                        break;
                    }
                }
                fclose(checkFile);
            }
    
            if (!exists) {
                fprintf(outCheatFile, "%s\n", cheatLine.c_str());
            }
    #else
            if (!cheatExists(cheatFilePath, cheatLine)) {
                outCheatFile << cheatLine << "\n";
            }
    #endif
        }
    
    #ifdef NO_FSTREAM_DIRECTIVE
        fclose(outCheatFile);
    #else
        outCheatFile.close();
    #endif
    
        return true;
    }
    
    
    // Corrected helper function to convert values to big-endian format
    uint32_t toBigEndian(uint32_t value) {
        return ((value & 0x000000FF) << 24) |
               ((value & 0x0000FF00) << 8)  |
               ((value & 0x00FF0000) >> 8)  |
               ((value & 0xFF000000) >> 24);
    }
    
    uint16_t toBigEndian(uint16_t value) {
        return ((value & 0x00FF) << 8) |
               ((value & 0xFF00) >> 8);
    }
    
    // Helper function to convert a vector of bytes to a hex string for logging
    
    std::string hexToString(const std::vector<uint8_t>& bytes) {
        std::ostringstream oss;
        for (uint8_t byte : bytes) {
            oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
        }
        return oss.str();
    }
    
    
    
    /**
     * @brief Converts a .pchtxt file to an IPS file using fstream.
     *
     * This function reads the contents of a .pchtxt file, extracts the address-value pairs,
     * and generates an IPS file with the provided output folder.
     *
     * @param pchtxtPath The file path to the .pchtxt file.
     * @param outputFolder The folder path for the output IPS file.
     * @return True if the conversion was successful, false otherwise.
     */
    bool pchtxt2ips(const std::string& pchtxtPath, const std::string& outputFolder) {
    #if NO_FSTREAM_DIRECTIVE
        // Use FILE* for reading
        FILE* pchtxtFile = fopen(pchtxtPath.c_str(), "r");
        if (!pchtxtFile) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Error: Unable to open file " + pchtxtPath);
            #endif
            return false;
        }
    
        std::vector<std::pair<uint32_t, std::vector<uint8_t>>> patches;
        std::string line;
        uint32_t lineNum = 0;
        std::string nsobid;
        int offset = 0; // Default offset
    
        uint32_t address;
        uint8_t byte;
        std::vector<uint8_t> valueBytes;
    
        while (fgets(&line[0], line.size(), pchtxtFile) != nullptr) {
            ++lineNum;
            if (line.empty() || line.front() == '@') {
                if (line.find("@nsobid-") == 0) {
                    nsobid = line.substr(8);
                }
                if (line.find("@flag offset_shift ") == 0) {
                    std::string offsetStr = line.substr(19);
                    offset = (offsetStr.find("0x") == 0 ? std::strtol(offsetStr.c_str(), nullptr, 16) : std::strtol(offsetStr.c_str(), nullptr, 10));
                }
                if (line.find("@stop") == 0) {
                    break;
                }
                continue;  // Skip empty lines and lines starting with '@'
            }
    
            std::istringstream iss(line);
            std::string addressStr, valueStr;
    
            if (!(iss >> addressStr >> valueStr)) {
                continue;
            }
    
            char* endPtr;
            address = std::strtoul(addressStr.c_str(), &endPtr, 16) + offset; // Adjust address by offset
            if (*endPtr != '\0') {
                continue;
            }
    
            for (size_t i = 0; i < valueStr.length(); i += 2) {
                byte = std::stoi(valueStr.substr(i, 2), nullptr, 16);
                valueBytes.push_back(byte);
            }
    
            if (valueBytes.empty()) {
                continue;
            }
    
            patches.push_back(std::make_pair(address, valueBytes));
            valueBytes.clear();
        }
    
        if (nsobid.empty()) {
            nsobid = pchtxtPath.substr(pchtxtPath.find_last_of("/\\") + 1);
            nsobid = nsobid.substr(0, nsobid.find_last_of("."));
        }
    
        fclose(pchtxtFile);
    
    #else
        // Use fstream for reading
        std::ifstream pchtxtFile(pchtxtPath);
        if (!pchtxtFile) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Error: Unable to open file " + pchtxtPath);
            #endif
            return false;
        }
    
        std::vector<std::pair<uint32_t, std::vector<uint8_t>>> patches;
        std::string line;
        uint32_t lineNum = 0;
        std::string nsobid;
        int offset = 0; // Default offset
    
        uint32_t address;
        uint8_t byte;
        std::vector<uint8_t> valueBytes;
    
        while (std::getline(pchtxtFile, line)) {
            ++lineNum;
            if (line.empty() || line.front() == '@') {
                if (line.find("@nsobid-") == 0) {
                    nsobid = line.substr(8);
                }
                if (line.find("@flag offset_shift ") == 0) {
                    std::string offsetStr = line.substr(19);
                    offset = (offsetStr.find("0x") == 0 ? std::strtol(offsetStr.c_str(), nullptr, 16) : std::strtol(offsetStr.c_str(), nullptr, 10));
                }
                if (line.find("@stop") == 0) {
                    break;
                }
                continue;  // Skip empty lines and lines starting with '@'
            }
    
            std::istringstream iss(line);
            std::string addressStr, valueStr;
    
            if (!(iss >> addressStr >> valueStr)) {
                continue;
            }
    
            char* endPtr;
            address = std::strtoul(addressStr.c_str(), &endPtr, 16) + offset; // Adjust address by offset
            if (*endPtr != '\0') {
                continue;
            }
    
            for (size_t i = 0; i < valueStr.length(); i += 2) {
                byte = std::stoi(valueStr.substr(i, 2), nullptr, 16);
                valueBytes.push_back(byte);
            }
    
            if (valueBytes.empty()) {
                continue;
            }
    
            patches.push_back(std::make_pair(address, valueBytes));
            valueBytes.clear();
        }
    
        if (nsobid.empty()) {
            nsobid = pchtxtPath.substr(pchtxtPath.find_last_of("/\\") + 1);
            nsobid = nsobid.substr(0, nsobid.find_last_of("."));
        }
    
        pchtxtFile.close();
    #endif
    
        // Trim any newline characters from nsobid
        trim(nsobid);
        trimNewline(nsobid);
    
        std::string ipsFileName = nsobid + ".ips";
        std::string ipsFilePath = outputFolder + ipsFileName;
    
    #if NO_FSTREAM_DIRECTIVE
        // Use FILE* for writing
        FILE* ipsFile = fopen(ipsFilePath.c_str(), "wb");
        if (!ipsFile) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Error: Unable to create IPS file " + ipsFilePath);
            #endif
            return false;
        }
    
        fwrite(IPS32_HEAD_MAGIC, sizeof(char), std::strlen(IPS32_HEAD_MAGIC), ipsFile);
    
        uint16_t valueLength;
        for (const auto& patch : patches) {
            uint32_t bigEndianAddress = toBigEndian(patch.first);  // Convert address to big-endian
            fwrite(&bigEndianAddress, sizeof(bigEndianAddress), 1, ipsFile);  // Write address
    
            valueLength = toBigEndian(static_cast<uint16_t>(patch.second.size()));  // Convert length to big-endian
            fwrite(&valueLength, sizeof(valueLength), 1, ipsFile);  // Write length of value
    
            fwrite(patch.second.data(), sizeof(uint8_t), patch.second.size(), ipsFile);  // Write value
        }
    
        fwrite(IPS32_FOOT_MAGIC, sizeof(char), std::strlen(IPS32_FOOT_MAGIC), ipsFile);
        fclose(ipsFile);
    #else
        // Use fstream for writing
        std::ofstream ipsFile(ipsFilePath, std::ios::binary);
        if (!ipsFile) {
            #if USING_LOGGING_DIRECTIVE
            logMessage("Error: Unable to create IPS file " + ipsFilePath);
            #endif
            return false;
        }
    
        ipsFile.write(IPS32_HEAD_MAGIC, std::strlen(IPS32_HEAD_MAGIC));
    
        uint16_t valueLength;
        for (const auto& patch : patches) {
            uint32_t bigEndianAddress = toBigEndian(patch.first);  // Convert address to big-endian
            ipsFile.write(reinterpret_cast<const char*>(&bigEndianAddress), sizeof(bigEndianAddress));  // Write address
    
            valueLength = toBigEndian(static_cast<uint16_t>(patch.second.size()));  // Convert length to big-endian
            ipsFile.write(reinterpret_cast<const char*>(&valueLength), sizeof(valueLength));  // Write length of value
    
            ipsFile.write(reinterpret_cast<const char*>(patch.second.data()), patch.second.size());  // Write value
        }
    
        ipsFile.write(IPS32_FOOT_MAGIC, std::strlen(IPS32_FOOT_MAGIC));
        ipsFile.close();
    #endif
    
        return true;
    }

}